import os
import csv
from DB import open_db, close_db, create_tables, insert_row_vulner
from tkinter import END

def load_db(data_folder, output):

    # csv_header = ["name","sequenceNumber","scanresultid","criticalDetails","severity","status","active","duration",
              # "concern","startTime","vulnerabilities","numHosts","solution","ipaddress","assetName","vulnerabilityInstances","risk",
              # "vulnid","openServices","description","scanProfileId","cancelled","runSchedule","vulnerability","cveid","exposureId","score","domainName"]
    if os.path.isdir(data_folder):
        output.insert(END, f'Loadind the files: {data_folder}\n')
    else:
        output.insert(END, f'Data folder does not exist: {data_folder}\n')
        return
    conn, cursor = open_db()
    create_tables(cursor) 
    for folder, subs, files in os.walk(data_folder):
        for f in files:
            filename, file_extension = os.path.splitext(f)
            if file_extension != ".csv":
                continue
            # print(folder.split('\\')[-2], ",", folder.split('\\')[-1], ",", filename)
            output.insert(END, filename + '\n')
            with open(os.path.join(os.path.join(folder, f))) as csv_file:
                csv_reader = csv.reader(csv_file, delimiter=',')
                for i, row in enumerate(csv_reader):
                    if len(row) != 28:
                        output.insert(END, f'filename skipped, # col are not 28, it is: {len(row)}" \n')
                        break
                    if row[0] != 'name':        # skip header
                        # output.insert(END, filename +  str(i) + '\n')
                        insert_row_vulner(conn, cursor, row)
    conn.commit()
    close_db(cursor)
    

def load_classification(data_folder):

    # csv_header = ["name","sequenceNumber","scanresultid","criticalDetails","severity","status","active","duration",
              # "concern","startTime","vulnerabilities","numHosts","solution","ipaddress","assetName","vulnerabilityInstances","risk",
              # "vulnid","openServices","description","scanProfileId","cancelled","runSchedule","vulnerability","cveid","exposureId","score","domainName"]
    
    # conn, cursor = open_db()
    # create_tables(cursor) 
    for folder, subs, files in os.walk(data_folder):
        for f in files:
            filename, file_extension = os.path.splitext(f)
            # if file_extension != ".xlsx":
                # continue
            print(folder, subs, filename)
            # with open(os.path.join(os.path.join(folder, f))) as csv_file:
                # csv_reader = csv.reader(csv_file, delimiter=',')
                # for i, row in enumerate(csv_reader):
                    # if len(row) != 28:
                        # print ('filename skipped, # col are not 28, it is ', len(row))
                        # break
                    # if row[0] != 'name':        # skip header
                        # print (filename, i)
                        # insert_row_vulner(conn, cursor, row)
    # conn.commit()
    # close_db(cursor)
    
    
def excel_to_csv(data_folder):
    
    for folder, subs, files in os.walk(data_folder):
        for f in files:
            filename, file_extension = os.path.splitext(f)
            print(filename)
            if file_extension != ".xlsx":
                continue
            fp = open(os.path.join(folder, filename+".csv"), "w", newline='')
            c = csv.writer(fp, delimiter = ',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
            xl_wb = load_workbook(os.path.join(os.path.join(folder, f)))
            for sheet in xl_wb:  # combine all sheets in one csv file
                for l, row in enumerate(sheet.rows):
                    if l == 0:  # skip header
                        header_idx = load_header_idx(row)
                    else:
                        # if filename == 'HQ-VLAN-87-Windows-Internet-Banking-Test-CM-FULL':
                            # y = 10
                        line = [''] * len(full_header)
                        for i, cell in enumerate(row):
                            line[header_idx[i]] = cell.value
                        
                        c.writerow(line)
            fp.close()

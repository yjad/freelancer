import os
import csv
import datetime
from DB import open_db, close_db, create_tables, insert_row_vulner, exec_db_cmd
from tkinter import END, messagebox
from openpyxl import load_workbook

FULL_HEADER = ["name","sequenceNumber","scanresultid","criticalDetails","severity","status","active","duration",
              "concern","startTime","vulnerabilities","numHosts","solution","ipaddress","assetName","vulnerabilityInstances","risk",
              "vulnid","openServices","description","scanProfileId","cancelled","runSchedule","vulnerability","cveid",
              "exposureId","score","domainName"]
              
def load_db(data_folder, output):

    if os.path.isdir(data_folder):
        # output.delete(0.0, END)        # clear window
        output.insert(END, f'Loadind the files: {data_folder}\n')
    else:
        output.insert(END, f'Data folder does not exist: {data_folder}\n')
        return
    conn, cursor = open_db()
    create_tables(cursor) 
    for folder, subs, files in os.walk(data_folder):
        for f in files:
            filename, file_extension = os.path.splitext(f)
            if file_extension != ".csv":
                continue
            # print(folder.split('\\')[-2], ",", folder.split('\\')[-1], ",", filename)
            output.insert(END, filename + '\n')
            with open(os.path.join(os.path.join(folder, f))) as csv_file:
                csv_reader = csv.reader(csv_file, delimiter=',')
                for i, row in enumerate(csv_reader):
                    if len(row) != 28:
                        output.insert(END, f'filename skipped, # col are not 28, it is: {len(row)}" \n')
                        break
                    if row[0] != 'name':        # skip header
                        # output.insert(END, filename +  str(i) + '\n')
                        insert_row_vulner(conn, cursor, row)
    conn.commit()
    exec_db_cmd("DELETE FROM stats")
    insert_stats("2020-09-22")
    exec_db_cmd("INSERT INTO stats VALUES('2020-09-22', 1 , 'AIX-Servers', 'AIX Servers milestone-1 (NEW)', 0,0,0,0,0,0)")
    close_db(cursor)
    

def excel_to_csv_folder(data_folder):
    
    for folder, subs, files in os.walk(data_folder):
        for f in files:
            filename, file_extension = os.path.splitext(f)
            print(filename)
            if file_extension != ".xlsx":
                continue
            excel_to_csv_file(os.path.join(folder, f))
            fp.close()


def excel_to_csv_file(excel_file_path):
    filename, file_extension = os.path.splitext(excel_file_path)
    csv_file_path = filename+".csv"
    if os.path.exists(csv_file_path):
        if not messagebox.askyesno("Confirm", f"file {csv_file_path} already exist, overrite it?"):
            return
    fp = open(csv_file_path, "w", newline='')
    c = csv.writer(fp, delimiter = ',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    xl_wb = load_workbook(excel_file_path)
    for sheet in xl_wb:  # combine all sheets in one csv file
        for l, row in enumerate(sheet.rows):
            if l == 0:  # map header to full Qradar header
                header_idx = load_header_idx(row)
            else:
                # if filename == 'HQ-VLAN-87-Windows-Internet-Banking-Test-CM-FULL':
                    # y = 10
                line = [''] * len(FULL_HEADER)
                for i, cell in enumerate(row):
                    line[header_idx[i]] = cell.value
                c.writerow(line)
    fp.close()
    messagebox.showinfo("Done","Done")
    
def load_header_idx(header):
    
    
    header_idx= [-1] * len(FULL_HEADER)

    for i, col in enumerate(header):
        if col.value:
            x = FULL_HEADER.index(col.value)
            if x != -1:
                header_idx[i] = x
    return header_idx
   
   
def insert_stats(scan_date):
    # ----- Insert new scan results
    # *** delete same days stats, if any ***
    # cmd = f"DELETE FROM stats where date = '{datetime.date.today()}'"
    # exec_db_cmd(cmd)
    
    cmd = f"""INSERT INTO stats 
    SELECT '{scan_date}' as "Date", ms.milestone, vlan_group, ms.profile_name,
    COUNT(distinct assets.ipaddress) as "numHosts",
	COUNT(CASE WHEN risk = 'High' Then 1 END) as 'High', 
	COUNT(CASE WHEN risk = 'Medium' Then 1 END) as 'Medium',
	COUNT(CASE WHEN risk = 'Low' Then 1 END) as 'Low',
	COUNT(CASE WHEN risk = 'Warning' Then 1 END) as 'Warning',
	COUNT(risk) as "Total"
    FROM vulnerability vul 
		LEFT JOIN assets on assets.ipaddress = vul.ipaddress
		LEFT JOIN milestone ms on vul.name = ms.profile_name
    GROUP by vlan_group, ms.milestone, ms.profile_name
    ORDER BY 2"""
    exec_db_cmd(cmd)
    
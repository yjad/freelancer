import sqlite3
import sys
import os 
from openpyxl import Workbook
from tkinter import END, messagebox

#from config import config
DB_FILE_NAME = r".\data\vulnerability.sqlite"

def open_db():
    if not os.path.exists(DB_FILE_NAME):
        print (f"database file {DB_FILE_NAME} does not exist")
        exit(-1)
    connection = sqlite3.Connection(DB_FILE_NAME)
    cursor = connection.cursor()
    return connection, cursor


def create_tables(cursor):
    #cmd = 'CREATE TABLE IF NOT EXISTS vulnerability ' \
    cursor.execute("drop table IF EXISTS vulnerability")
    cmd = 'CREATE TABLE vulnerability ' \
            '(name			TEXT,' \
            'sequenceNumber	INTEGER,' \
            'scanresultid	INTEGER,' \
            'criticalDetails	TEXT,' \
            'severity		TEXT,' \
            'status			TEXT,' \
            'active			TEXT,' \
            'duration		TEXT,' \
            'concern		TEXT,' \
            'startTime		TEXT,' \
            'vulnerabilities	INTEGER,'\
            'numHosts		INTEGER,'\
            'solution		TEXT,'\
            'ipaddress		TEXT,'\
            'assetName		TEXT,'\
            'vulnerabilityInstances	INTEGER,'\
            'risk			TEXT,'\
            'vulnid			INTEGER,'\
            'openServices	INTEGER,'\
            'description	TEXT,'\
            'scanProfileId	INTEGER,'\
            'cancelled		TEXT,'\
            'runSchedule	TEXT,'\
            'vulnerability	TEXT,'\
            'cveid			TEXT,'\
            'exposureId		INTEGER,' \
            'score			FLOAT,'\
            'domainName		TEXT)'
    cursor.execute(cmd)

    
    return


def close_db(cursor):
    cursor.close()


def insert_row_dict(conn, cursor, table_name, rec):
    keys = ','.join(rec.keys())
    question_marks = ','.join(list('?' * len(rec)))
    values = tuple(rec.values())
    try:
        cursor.execute('INSERT INTO ' + table_name + ' (' + keys + ') VALUES (' + question_marks + ')', values)
        conn.commit()
        return 0
    except sqlite3.Error as er:
        #print('SQLite error: %s' % (' '.join(er.args)))
        #print("Exception class is: ", er.__class__)
        #print('SQLite traceback: ')
        #exc_type, exc_value, exc_tb = sys.exc_info()
        #print(traceback.format_exception(exc_type, exc_value, exc_tb))
        return -1

def insert_row_list(conn, cursor, table_name, rec):


    question_marks = ','.join(list('?' * len(rec)))
    try:
        cursor.execute('INSERT INTO ' + table_name + ' VALUES (' + question_marks +')', tuple(rec))
        # conn.commit()
        return 0
    except sqlite3.Error as er:
        print('SQLite error: %s' % (' '.join(er.args)))
        print("Exception class is: ", er.__class__)
        print('SQLite traceback: ')
        exc_type, exc_value, exc_tb = sys.exc_info()
        #print(traceback.format_exception(exc_type, exc_value, exc_tb))
        print(exc_type, exc_value, exc_tb)
        exit(-1)
        return -1
        
        
def exec_db_cmd(cmd):
    
    conn, cursor = open_db()
    try:
        cursor.execute(cmd)
        conn.commit()
        close_db(cursor)
        return 0
    except sqlite3.Error as er:
        print('SQLite error: %s' % (' '.join(er.args)))
        print("Exception class is: ", er.__class__)
        print('SQLite traceback: ')
        exc_type, exc_value, exc_tb = sys.exc_info()
        #print(traceback.format_exception(exc_type, exc_value, exc_tb))
        print(exc_type, exc_value, exc_tb)
        exit(-1)
        return -1
        
def insert_row_vulner(conn, cursor, rec):
    return insert_row_list(conn, cursor, 'vulnerability', rec)


def exec_query(cursor, cmd):
    cursor.execute(cmd)
    rows = cursor.fetchall()
    return rows


def get_col_names(conn, sql):
    get_column_names = conn.execute(sql + " limit 1")
    col_name = [i[0] for i in get_column_names.description]
    return col_name
    

def query_to_excel(cmd, file_name, header=None):
    conn, cursor = open_db()
    rows = exec_query(cursor, cmd)

    if not header:
        header = get_col_names(conn, cmd)
    close_db(cursor)
    
    wb = Workbook()
    ws = wb.active
    ws.title = os.path.splitext(os.path.basename(file_name))[0]
    ws.append(header)

    for row in rows:
        ws.append(row)
    try:
        wb.save(file_name)
    except:
        print ("error saving to excel file ...")

    messagebox.showinfo("Done!",f"file exported {file_name}! ")
    
def query_to_list(cmd):
    conn, cursor = open_db()
    rows = exec_query(cursor, cmd)
    if cmd.upper().find("LIMIT") != -1:   # if command have "Limit clause, dont return header
        header = []
    else:
        header = get_col_names(conn, cmd)
    close_db(cursor)
    return header, rows